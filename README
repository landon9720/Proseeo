Proseeo  A new way for groups to communicate, organize, and get stuff done.
         "I am the cutest little bug tracking software there is!"

         plans


         routing

         reporting

         distributed - Proseeo keeps project files on your local file system.
                       Project files are shared using using your source control tools.

     softer software - Proseeo trusts you to make good decisions about your process.



         ok ok

tools:
one program: proseeo
talk to it like you talk to siri
proseeo init
proseeo start story
proseeo use <guid>
proseeo comment ipsum
proseeo forward to ipsuser
proseeo report

lower level. what are the tools:
command line language parser and syntax tree
command line execution engine
story language parser and syntax tree
story execution engine to arrive at current document state
  including the important (but easy??) active chain & tip algorithm
indexer (push all stories into mongo)
reporter pass user defined mongo queries to mongo and handle results (no custom dsl for now, but in future)
appender writes to story
configuration file format, parser, writer
  some commands (like the use command) will need to store state there
???

steve> proseeo open story -title "bug?"
Created stories/<guid>.proseeo
steve> cd <guid>
steve> comment "i just talked to etc..."
steve> forward to anthony
Forwarded to user anthony (Anthony A)
anthony> proseeo create report -title "mine"
Created reports/<guid>.report
anthony> echo "{open: true}" > reports/<guid>.report
anthony> proseeo report -title "mine"
stories/<guid>.proseeo
  created by steve (Steve A) on xx/xx/xx
  "i just talked to etc..."
anthony> cd <guid>.proseeo
anthony> proseeo ask steve "i need a screenshot"

steve> proseeo report
stories/<guid>.proseeo
  asked by adupre (Anthony A) on xx/xx/xx
  "i need a screenshot!"
steve> cd <guid>
steve> proseeo attach screenshot1.png
Attached screenshot1.png
steve> proseeo


need a way to report on what is mine.
stories in which i am in the active chain
the critical question i have not answered here is
  "how do i view my in-box?"
  "well there is no in-box."
  "well i want an in-box."

in the above use cases the story should have been in anthony's, and then engineerings's, "in boxes"
because: at the time, they were at the tip of the active chain
so every story: evaluate to find active chain and active tip

steve notes """
  i just talked to abc in and their xyg feature isnot working,
  please look into this
"""
steve forwards with feedback to user anthony
anthony comments "yes i can duplicate this. we will fix it."
anthony sets template to bug <---- think about this!
anthony sets bug.fix_version = 1.0.2.3
anthony forwards to engineering
pinned by landon <------- think about this!!!!
pinned by zach
zach comments "i think i know what caused this...."
landon comments "found and fixed"
landon sets bug.fixed = true
chris sets bug.tested = true

...

this doesn't even wrap git
it's just a collection of command line tools for
  parsing these documents
  updating these documents
  indexing them
  providing querying and reporting services
  later: signing and encryption!!!!
stores these as a plain-text document right on the file system
filenames in the format: guid.proseeo -- it's a directory! inside is the script, and attachments!
an indexer can crawl all these documents to build a reportable index
  using mongo
  but don't checkin the mongo database! no need. :) the tools can
  rebuild when needed
report query language..maybe native mongo queries at first
there needs to be conf files
  ./.proseeo.conf
    users
      listed so that user references can be validated
    groups
      listed for the same reason
    basically anything that might need to be referenced should be configured
    with metadata (name, email address, etc.) which will allow tools
    to annotate those references, send emails, etc.
  ~/.proseeo.conf
    smtp.setting1 =
    smpt.setting2 = etc ... allows tools to send messages on user's behalf

Welcome to com.landonkuhn.proseeo.main.Proseeo
Here I am building a platform to help groups get stuff done. This is distributed
process structure. DPS. This is soft business process management.
This is a new way for groups to communicate, to organize, and to get stuff done.
I am starting with business of making software. This is the work I know, and the
first who will use this.

it really has no dependencies on git all all
any source control will do! ha!

going to need it to be an sbt probject
going to need to publish a brew formula

at some point worry about:
  story file encoding
  story archiving

active chain and tip:
created by user A
A assigned to user B
B asked of user A
A responded
B assigned to group C
user D closed

pretty simple. just follow the arrows:
   created by establsihes the starting point
   assigned to user is a 1:1 arrow with no implied next destination
   ask of user is a 1:1 arrow with implied return to sender on "respond"
   assigned to group is a 1:* arrow with no implied next destination
   ask of group is a 1:* arrow with implied return to sender on "respond" by any 1 group member

we can now report on:
   stories that i am in the active chain
   stories that i am at the tip of the active chain
   stories that i am at the tip of the active chain and i am being asked something
   ditto for the last two, but due to group membership
these are reports against the story state itself, not the document state
they are built on built-in concepts in the story model
described above is the "routing" for stories


pro-see-oh

signing: a way to sign a story to assert authorship from th2is point back to the previous signing
encryption: a way to encrypt parts of the document?? i don't know. this is less interesting to me because i value building an open system. ideally with a slick front end that allows full text searching --- this data should be a repo for information.

git is clunky, that's ok, this is for the hardcore, a web interface can come later, a IOS interface too

could it work for the mongo database to actually live on the network and be shared? i think perhaps it is so!
  --- OR NOT! -- somebody's local repo could be out of date.

perhaps proseeo is business process management inspired by twitter




=== document templating ===

dsl to describe requirements?

/templates/bug <-- name of file

needs title:text
needs description:text
optional version_reported_in:named_enum(versions)

needs scrubbed:gate

needs version_assignment:named_enum(versions)

needs fixed_in_version:named_enum(versions)
needs release_note:text
needs fixed:gate

needs test_note:text
needs tested:gate

...
could the document itself somehow advise routing?
...

       title               : color on home page does not match(bright)
       description         : etc etc blah blah(bright)
  want version_reported_in : 2.4, 2.3, 2.2, 13 more(dim)

       scrubbed            : [/] by Landon Kuhn 2 day(s) ago(bright)

  need version_assignment  : 1.1(bright) 2.4, 2.3, 2.2, 13 more(dim)

       fixed_in_version    : 2.4(bright)
  need release_note        : > ____ < (dim)
  need fixed               : > [ ] < (dim)

       test_note(dim)
       tested
       foo_field
       bar_field

       14 more







what's next:
  document templating
  tagging
  group member pinning
  routing use cases: ask, pass
  indexer and queries
  generated file header comments
  attachments and multiline values
  command suggestions, undo
  .
  .
  .
  linking
  signing
  .
  .
  .
  brew formula
  eclipse task connector
  file encoding
  archiving
  jira import
  egit integration

spinny:
  [-  ]
  [ - ]
  [  -]


I want to say a little about my philosophy of the way I think software should be.

Actually, I want to say something about the way programmers should work.

Programmers communicate users. The media and method of communication is the software. The programmer is the sender, and the user is the receiver. With most software this is almost an abusive relationship. I want to change that.

As programmers building a complex system we make thousands of small tiny decisions. Those decisions are informed by product requirements, culture, and habit. But there is something missing. In addition to requirements, and culture, there's something else we should



   created : 1/1/2000 3 hours ago by Landon Kuhn <lkuhn> lkuhn@example.com
   ended   : 1/1/2000 1 minutes ago by Landon Kuhn <lkuhn>             // only if ended
   route   : creator ~> sbob ~> lkuhn(bold) ~> then1 ~> then2

   no comments yet // or 6 comments

   "blaah blaahhl baahh blaaah"
     by Steve Bob <sbob> 1 hours ago

   "zabbit zabbity"
     by Landon Kuhn <lkuhn> 1 hours ago

   bug // or (no plan)

   >  need title                ____
   >  need description          ____
   >  want version_reported_in  2.1, 2.0, 1.5, 1.4, 5 more

      need scrubbed   [ ]
      need scrubbed2  [ ]

      want color red, blue, green, black, 2 more

ok ok

p cat story
p cat plan (current)
p cat plan name

p edit story
p edit plan // creates story copy
p edit plan --project // edits project copy

script:
  attach "filename" by lkuhn @ ... # filename expected to be in story dir
  detach "filename" by lkuhn @ ...

p:
  p attach ~/Desktop/screenshot.jpg # file is copied into story dir as screenshot.jpg
  p attach ~/Desktop/foo/screenshot.jpg # this would fail
  p attach ~/Desktop/foo/screenshot.jpg as screenshot2.jpg # file is copied into story dir as screenshot2.jpg
  p detach screenshot.jpg # removes it from the script state, but not the file system
  p attach new release_document.md # touches release_document.md in story dir. perhaps in the future support a with template keywoard

i think the command line parser will work better if it takes the token stream as passed in as args

release plan
  need version:text
  want summary:text
  need release_date:timestamp
  need release_document:attachment

  need accepted:gate

p set release_date now + 1d 1h # now and today keywords with + and - operators with human string operands
p set release_date now + 1d 2h
p set release_date today + 1d

p tell
  ...
1) screenshot.jpg
2) screenshot2.jpg

p open attachment 1 # invoke system viewer
p edit attachment 2 # invoke system editor

error messages should be written as if the programmer is sitting with the user and walking them through their use case

plan field type: date
use case: due date field
set with commands like "p set due in 2w"
reporting use cases: sort by due date, filter on past due

stories should have a name instead of a uuid
use: p create bug
where bug is the name of the story and the immediate subdir of the project dir
if it already exists then bug-n is created instead and a warning is issued
